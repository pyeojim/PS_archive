#1629

a,b,c = map(int, input().split())

b = str(bin(b))[2:]

def divideCon(m1, m2, m3):
    if m2 == 0:
        return m1%m3
    elif m1 > m3:
        return divideCon(m1%m3, m2, m3)
    else:
        return divideCon(m1**2, m2-1, m3)

cache = 1

for x in range(len(b)):
    if int(b[x]):
        cache *= divideCon(a,(len(b)-x-1), c)
    else:
        pass

print(cache%c)



"""
당연히 실버1인데 (a ** b) % c 한줄로 풀릴리가 없고..
input 값이 int 자료형의 한계치까지 들어갈 수 있다는 것에서 싸함이 느껴져야 한다.

divide-conquer 방식으로 접근해서 풀어야 하는 문제이다.
가장 많은 시간을 소요하리라 여겨지는 부분은 a를 b번 제곱하는 부분으로,
a가 어떤 수이든 간에, 2,147,483,647번씩이나 거듭제곱을 해야하기 때문이다.

따라서 b를 최대한 감소시키는(즉, 거듭제곱의 지수를) 어떻게든 줄이는 방향으로 접근해야 한다.

여기부터는 컴퓨터 알고리즘이기도 하지만?
고등학교 수학을 푸는 느낌으로 살짝 식을 해석하는 부분이 필요하다.

5의 7제곱을 2로 나눈 나머지를 구한다고 해보자.

(5 * 5 * 5 * 5 * 5 * 5 * 5) % 2라고 할 수 있다. 

이 식은 다음과 같이 변형할 수 있다.

(2*2 + 1) * (2*2 + 1) ..... * (2*2 + 1)

위 식을 실제로 곱하면, 이항정리에 의해, 2를 인수로 가지지 않은 항은
맨 마지막의 1**7밖에 남지 않는다. 

즉, 5의 7제곱을 2로 나눈 나머지를 직접 구하지 않아도, 
5를 2로 나눈 나머지를 일단 구하고, 
이걸 7제곱한걸 2로 다시 나눠도 된다는 것이다.

이를 응용하면, 
8의 16제곱을 3으로 나눈 나머지는 다음과 같이 구할 수 있다. 

(8 ** 16) % 3
= (2 ** 16) % 3
= (16 ** 4) % 3
= (1 ** 4) % 3
= 1

a와 b가 모두 획기적으로 줄어드는 것을 관찰할 수 있다.
(2로만 계속 나눠도, binary search를 구현해봤다면 놀랄만한 수도 금방 처리할 수 있음을 알 것이다)

근데 지수가 2의 거듭제곱으로 나온다는 보장이 없지 않냐고 할 수 있다. 
(반드시 밑이 2일 필요는 없다만.. 밑이 뭐든 그것의 거듭제곱꼴로 지수 b가 나온다는 보장이 없음)

이를 해결하기 위해서는, 지수를 이진수로 나타내면 된다. 

예를 들어, 11의 7제곱이라고 한다면,
(11 ** 4) * (11 ** 2) * (11 ** 1) 이렇게 쪼개서 하면 된다는 얘기다.

그러면? 각 항을 위에서 언급한 알고리즘으로 쪼개주고,
그 값을 모두 곱한것의 나머지를 구하면 된다.

방금 언급한 예시를 3으로 나누는 경우로 바로 적용하면,

[(11 ** 4) * (11 ** 2) * (11 ** 1)] % 3
= {[(2 ** 4) % 3] * [(2 ** 2) % 3] * (2 % 3)} % 3
= {[(4 ** 2) % 3] * 1 * 2} % 3
= {[(1 ** 2) % 3] * 2} % 3
= 2 % 3
= 2

이렇게 된다는 얘기다.
"""



